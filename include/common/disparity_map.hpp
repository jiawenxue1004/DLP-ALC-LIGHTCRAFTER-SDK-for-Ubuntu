/** @file       disparity_map.hpp
 *  @ingroup    Common
 *  @brief      Defines the DisparityMap class for use with \ref dlp::StructuredLight and \ref dlp::Geometry classes
 *  @copyright  2016 Texas Instruments Incorporated - http://www.ti.com/ ALL RIGHTS RESERVED
 */

#ifndef DLP_DISPARITY_MAP_HPP
#define DLP_DISPARITY_MAP_HPP

#include <common/debug.hpp>
#include <common/pattern/pattern.hpp>
#include <common/returncode.hpp>
#include <common/image/image.hpp>

#define DISPARITY_MAP_PIXEL_OUT_OF_RANGE        "DISPARITY_MAP_PIXEL_OUT_OF_RANGE"
#define DISPARITY_MAP_PIXEL_VALUE_INVALID       "DISPARITY_MAP_PIXEL_VALUE_INVALID"
#define DISPARITY_MAP_EMPTY                     "DISPARITY_MAP_EMPTY"
#define DISPARITY_MAP_NULL_POINTER_COLUMNS      "DISPARITY_MAP_NULL_POINTER_COLUMNS"
#define DISPARITY_MAP_NULL_POINTER_ROWS         "DISPARITY_MAP_NULL_POINTER_ROWS"
#define DISPARITY_MAP_NULL_POINTER_ORIENTATION  "DISPARITY_MAP_NULL_POINTER_ORIENTATION"

/** @brief  Contains all DLP SDK classes, functions, etc. */
namespace dlp{

/** @class      DisparityMap
 *  @ingroup    Common
 *  @brief      Image container, with pixel validation masking, that stores the difference
 *              in location of an object between two images caused by vertical or horizontal
 *              parallax.
 *
 *  DisparityMap objects are generated by \ref dlp::StructuredLight objects after decoding
 *  the captured images from a camera. The \ref dlp::Geometry class uses this information
 *  to generate a \ref dlp::Point::Cloud.
 *
 *  Only a single parallax direction can be used per DisparityMap object. For maximum
 *  accuracy both vertical and horizontal structured light patterns should be used
 *  to generate two DisparityMap objects.
 *
 *  \note   Currently the \ref dlp::Geometry::GeneratePointCloud() class ONLY generates
 *          \ref dlp::Point::Cloud objects by using BOTH vertical and horizontal disparity maps.
 *
 */
class DisparityMap
{
public:
    DisparityMap();
    ~DisparityMap();
    //DisparityMap(const DisparityMap &map);

    DisparityMap(const unsigned int &columns, const unsigned int &rows, const dlp::Pattern::Orientation &orientation);
    DisparityMap(const unsigned int &columns, const unsigned int &rows, const dlp::Pattern::Orientation &orientation, const unsigned int &over_sample);

    ReturnCode Create(const unsigned int &columns, const unsigned int &rows, const dlp::Pattern::Orientation &orientation);
    ReturnCode Create(const unsigned int &columns, const unsigned int &rows, const dlp::Pattern::Orientation &orientation, const unsigned int &over_sample);
    ReturnCode Create(DisparityMap map);
    void Clear();
    bool isEmpty() const;

    ReturnCode GetColumns(unsigned int *columns);
    ReturnCode GetRows(unsigned int *rows);
    ReturnCode GetOrientation(dlp::Pattern::Orientation *orientation);
    ReturnCode GetDisparitySampling(unsigned int *over_sample);

    ReturnCode SetPixel(const unsigned int &x_col, const unsigned int &y_row, const int &value);
    ReturnCode SetPixelInvalid(const unsigned int &x_col, const unsigned int &y_row);
    void Unsafe_SetPixel(const unsigned int &x_col, const unsigned int &y_row, const int &value);
    void Unsafe_SetPixelInvalid(const unsigned int &x_col, const unsigned int &y_row);

    ReturnCode GetPixel(const unsigned int &x_col, const unsigned int &y_row, int *value);
    ReturnCode GetPixel(const unsigned int &x_col, const unsigned int &y_row, int *value, bool *valid);
    void Unsafe_GetPixel(const unsigned int &x_col, const unsigned int &y_row, int *value);
    void Unsafe_GetPixel(const unsigned int &x_col, const unsigned int &y_row, int *value, bool *valid);

    ReturnCode FlipImage( const bool &flip_x, const bool &flip_y);

    ReturnCode  GetOpenCVData(cv::Mat *data)const;
    ReturnCode  Unsafe_GetOpenCVData(cv::Mat *data);

    ReturnCode OversampleAndSmooth(const unsigned int &over_sample);

    dlp::Image GetImage();

    static const int INVALID_PIXEL;     /*!< Constant value used to mask pixels that do NOT contain valid disparity information */
    static const int EMPTY_PIXEL;

private:
    dlp::Image map_;
    dlp::Pattern::Orientation orientation_;
    unsigned int over_sample_;
};

}

#endif // DISPARITY_MAP_H
